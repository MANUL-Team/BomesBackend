stages:
  - build-docker
  - deploy-dev

workflow:
  rules:
    # Пайплайн в контексте MR
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    # Если контекст коммита, но есть открытый MR, то НЕ запускаемся
    - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS'
      when: never
    # Одинокий коммит ИЛИ тэг
    - if: '$CI_COMMIT_BRANCH || $CI_COMMIT_TAG'

variables:
  PARENT_PIPELINE_SOURCE: "$CI_PIPELINE_SOURCE"
  PARENT_LABELS: "$CI_MERGE_REQUEST_LABELS"

.trigger:
  trigger:
    # Автомагически подбираем нужный файл
    include:
      - local: Services/$PROJECT/.gitlab-ci.yml
    strategy: depend 
    # Передаем переменные в дочерние пайплайны
    forward:
      # Переменные CI, например, секреты
      pipeline_variables: true
      # Переменные из глобального блока variables
      yaml_variables: true
  rules:
    # Если есть изменения в сервисе или в темплейте пайплайна(этот файл), то собираем соответствующий микросервис
    - changes:
        paths:
          - gitlab-ci/**/*
          - Services/$PROJECT/**/*
      when: always
    - when: manual
  allow_failure: true



# При добавлении сервиса копируем блок ниже и вставляем свои названия. Смотреть также .gitlab-ci.yml нового сервиса и compose.yml

###
HTTP/Core_build: #<-- Здесь (Название сервиса)_build
  stage: build-docker
  extends: .trigger
  variables:
    PROJECT: "HTTP/Core" #<-- Здесь PROJECT: "(Название сервиса)"
###

HTTP/AuthService_build:
  stage: build-docker
  extends: .trigger
  variables:
    PROJECT: "HTTP/AuthService"

BomesWebDeploy:
  stage: deploy-dev
  script:
    - for yaml in $(sudo ls -la ./k3s_deploy/ | grep bomes | grep .yaml | awk '{print $9}'); do sudo kubectl apply -f ./k3s_deploy/$yaml; sudo kubectl rollout restart deployment/$(sudo cat ./k3s_deploy/$yaml | grep metadata -A 1 | grep name | grep -v service | grep -v ingress  | awk '{print $2}') || true; done
